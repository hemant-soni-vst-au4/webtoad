{"version":3,"sources":["./node_modules/@ionic/core/dist/esm/ion-infinite-scroll_2.entry.js","./node_modules/@ionic/core/dist/esm/index-9e3fe806.js","./node_modules/@ionic/core/dist/esm/ionic-global-63a97a32.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4I;AAClE;AACb;;AAE7D,+CAA+C,aAAa,WAAW,yBAAyB,cAAc;;AAE9G;AACA;AACA,IAAI,4DAAgB;AACpB,uBAAuB,4DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4DAAS;AACf;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAS;AACrB;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA,YAAY,4DAAC,CAAC,oDAAI,GAAG;AACrB;AACA;AACA;AACA,OAAO,EAAE;AACT;AACA,YAAY,QAAQ,4DAAU,OAAO;AACrC,yBAAyB;AACzB;AACA;AACA,IAAI;AACJ;AACA;;AAEA,iEAAiE,oBAAoB,aAAa,0BAA0B,sBAAsB,qBAAqB,uBAAuB,gBAAgB,kBAAkB,yBAAyB,sBAAsB,qBAAqB,iBAAiB,kBAAkB,cAAc,eAAe,aAAa,mBAAmB,aAAa,WAAW,uBAAuB,iBAAiB,kBAAkB,eAAe,gBAAgB,+FAA+F,uBAAuB,kBAAkB,mBAAmB,0BAA0B,yBAAyB,wBAAwB,wBAAwB,uEAAuE,cAAc,oDAAoD,yCAAyC,oPAAoP,0CAA0C,0OAA0O,wCAAwC;;AAEr9C,gEAAgE,oBAAoB,aAAa,0BAA0B,sBAAsB,qBAAqB,uBAAuB,gBAAgB,kBAAkB,yBAAyB,sBAAsB,qBAAqB,iBAAiB,kBAAkB,cAAc,eAAe,aAAa,mBAAmB,aAAa,WAAW,uBAAuB,iBAAiB,kBAAkB,eAAe,gBAAgB,+FAA+F,uBAAuB,kBAAkB,mBAAmB,0BAA0B,yBAAyB,wBAAwB,wBAAwB,uEAAuE,cAAc,mDAAmD,yCAAyC,+OAA+O,0CAA0C,uOAAuO,wCAAwC;;AAE38C;AACA;AACA,IAAI,4DAAgB;AACpB;AACA;AACA;AACA,mBAAmB,mEAAU;AAC7B,4BAA4B,2DAAM,+BAA+B,2DAAM;AACvE;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B,YAAY,4DAAC,CAAC,oDAAI,GAAG;AACrB;AACA;AACA,oCAAoC,KAAK;AACzC,OAAO,EAAE,EAAE,4DAAC,SAAS,4BAA4B,0BAA0B,4DAAC,SAAS,oCAAoC,EAAE,4DAAC,iBAAiB,4BAA4B,0BAA0B,4DAAC,SAAS,4CAA4C,4DAAiB,oBAAoB;AAC9R;AACA;AACA;AACA;AACA;AACA;;AAEuG;;;;;;;;;;;;;ACtOvG;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mBAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;;;;;;;;;;;;;ACpIxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,4DAAO;AACxB;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,4BAA4B,uBAAuB;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,4DAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAE6F","file":"10-es2015.js","sourcesContent":["import { r as registerInstance, e as createEvent, c as writeTask, f as readTask, h, i as getElement, H as Host } from './index-7a8b7a1c.js';\nimport { b as getIonMode, c as config } from './ionic-global-63a97a32.js';\nimport { s as sanitizeDOMString } from './index-9e3fe806.js';\n\nconst infiniteScrollCss = \"ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}\";\n\nconst InfiniteScroll = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionInfinite = createEvent(this, \"ionInfinite\", 7);\n    this.thrPx = 0;\n    this.thrPc = 0;\n    this.didFire = false;\n    this.isBusy = false;\n    this.isLoading = false;\n    /**\n     * The threshold distance from the bottom\n     * of the content to call the `infinite` output event when scrolled.\n     * The threshold value can be either a percent, or\n     * in pixels. For example, use the value of `10%` for the `infinite`\n     * output event to get called when the user has scrolled 10%\n     * from the bottom of the page. Use the value `100px` when the\n     * scroll is within 100 pixels from the bottom of the page.\n     */\n    this.threshold = '15%';\n    /**\n     * If `true`, the infinite scroll will be hidden and scroll event listeners\n     * will be removed.\n     *\n     * Set this to true to disable the infinite scroll from actively\n     * trying to receive new data while scrolling. This is useful\n     * when it is known that there is no more data that can be added, and\n     * the infinite scroll is no longer needed.\n     */\n    this.disabled = false;\n    /**\n     * The position of the infinite scroll element.\n     * The value can be either `top` or `bottom`.\n     */\n    this.position = 'bottom';\n    this.onScroll = () => {\n      const scrollEl = this.scrollEl;\n      if (!scrollEl || !this.canStart()) {\n        return 1;\n      }\n      const infiniteHeight = this.el.offsetHeight;\n      if (infiniteHeight === 0) {\n        // if there is no height of this element then do nothing\n        return 2;\n      }\n      const scrollTop = scrollEl.scrollTop;\n      const scrollHeight = scrollEl.scrollHeight;\n      const height = scrollEl.offsetHeight;\n      const threshold = this.thrPc !== 0 ? (height * this.thrPc) : this.thrPx;\n      const distanceFromInfinite = (this.position === 'bottom')\n        ? scrollHeight - infiniteHeight - scrollTop - threshold - height\n        : scrollTop - infiniteHeight - threshold;\n      if (distanceFromInfinite < 0) {\n        if (!this.didFire) {\n          this.isLoading = true;\n          this.didFire = true;\n          this.ionInfinite.emit();\n          return 3;\n        }\n      }\n      else {\n        this.didFire = false;\n      }\n      return 4;\n    };\n  }\n  thresholdChanged() {\n    const val = this.threshold;\n    if (val.lastIndexOf('%') > -1) {\n      this.thrPx = 0;\n      this.thrPc = (parseFloat(val) / 100);\n    }\n    else {\n      this.thrPx = parseFloat(val);\n      this.thrPc = 0;\n    }\n  }\n  disabledChanged() {\n    const disabled = this.disabled;\n    if (disabled) {\n      this.isLoading = false;\n      this.isBusy = false;\n    }\n    this.enableScrollEvents(!disabled);\n  }\n  async connectedCallback() {\n    const contentEl = this.el.closest('ion-content');\n    if (!contentEl) {\n      console.error('<ion-infinite-scroll> must be used inside an <ion-content>');\n      return;\n    }\n    this.scrollEl = await contentEl.getScrollElement();\n    this.thresholdChanged();\n    this.disabledChanged();\n    if (this.position === 'top') {\n      writeTask(() => {\n        if (this.scrollEl) {\n          this.scrollEl.scrollTop = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;\n        }\n      });\n    }\n  }\n  disconnectedCallback() {\n    this.enableScrollEvents(false);\n    this.scrollEl = undefined;\n  }\n  /**\n   * Call `complete()` within the `ionInfinite` output event handler when\n   * your async operation has completed. For example, the `loading`\n   * state is while the app is performing an asynchronous operation,\n   * such as receiving more data from an AJAX request to add more items\n   * to a data list. Once the data has been received and UI updated, you\n   * then call this method to signify that the loading has completed.\n   * This method will change the infinite scroll's state from `loading`\n   * to `enabled`.\n   */\n  async complete() {\n    const scrollEl = this.scrollEl;\n    if (!this.isLoading || !scrollEl) {\n      return;\n    }\n    this.isLoading = false;\n    if (this.position === 'top') {\n      /**\n       * New content is being added at the top, but the scrollTop position stays the same,\n       * which causes a scroll jump visually. This algorithm makes sure to prevent this.\n       * (Frame 1)\n       *    - complete() is called, but the UI hasn't had time to update yet.\n       *    - Save the current content dimensions.\n       *    - Wait for the next frame using _dom.read, so the UI will be updated.\n       * (Frame 2)\n       *    - Read the new content dimensions.\n       *    - Calculate the height difference and the new scroll position.\n       *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.\n       * (Still frame 2, if I'm correct)\n       *    - Change the scroll position (= visually maintain the scroll position).\n       *    - Change the state to re-enable the InfiniteScroll.\n       *    - This should be after changing the scroll position, or it could\n       *    cause the InfiniteScroll to be triggered again immediately.\n       * (Frame 3)\n       *    Done.\n       */\n      this.isBusy = true;\n      // ******** DOM READ ****************\n      // Save the current content dimensions before the UI updates\n      const prev = scrollEl.scrollHeight - scrollEl.scrollTop;\n      // ******** DOM READ ****************\n      requestAnimationFrame(() => {\n        readTask(() => {\n          // UI has updated, save the new content dimensions\n          const scrollHeight = scrollEl.scrollHeight;\n          // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around\n          const newScrollTop = scrollHeight - prev;\n          // ******** DOM WRITE ****************\n          requestAnimationFrame(() => {\n            writeTask(() => {\n              scrollEl.scrollTop = newScrollTop;\n              this.isBusy = false;\n            });\n          });\n        });\n      });\n    }\n  }\n  canStart() {\n    return (!this.disabled &&\n      !this.isBusy &&\n      !!this.scrollEl &&\n      !this.isLoading);\n  }\n  enableScrollEvents(shouldListen) {\n    if (this.scrollEl) {\n      if (shouldListen) {\n        this.scrollEl.addEventListener('scroll', this.onScroll);\n      }\n      else {\n        this.scrollEl.removeEventListener('scroll', this.onScroll);\n      }\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    const disabled = this.disabled;\n    return (h(Host, { class: {\n        [mode]: true,\n        'infinite-scroll-loading': this.isLoading,\n        'infinite-scroll-enabled': !disabled\n      } }));\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"threshold\": [\"thresholdChanged\"],\n    \"disabled\": [\"disabledChanged\"]\n  }; }\n};\nInfiniteScroll.style = infiniteScrollCss;\n\nconst infiniteScrollContentIosCss = \"ion-infinite-scroll-content{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;min-height:84px;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.infinite-loading{margin-left:0;margin-right:0;margin-top:0;margin-bottom:32px;display:none;width:100%}.infinite-loading-text{margin-left:32px;margin-right:32px;margin-top:4px;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.infinite-loading-text{margin-left:unset;margin-right:unset;-webkit-margin-start:32px;margin-inline-start:32px;-webkit-margin-end:32px;margin-inline-end:32px}}.infinite-scroll-loading ion-infinite-scroll-content>.infinite-loading{display:block}.infinite-scroll-content-ios .infinite-loading-text{color:var(--ion-color-step-600, #666666)}.infinite-scroll-content-ios .infinite-loading-spinner .spinner-lines-ios line,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-lines-small-ios line,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-crescent circle{stroke:var(--ion-color-step-600, #666666)}.infinite-scroll-content-ios .infinite-loading-spinner .spinner-bubbles circle,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-circles circle,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-dots circle{fill:var(--ion-color-step-600, #666666)}\";\n\nconst infiniteScrollContentMdCss = \"ion-infinite-scroll-content{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;min-height:84px;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.infinite-loading{margin-left:0;margin-right:0;margin-top:0;margin-bottom:32px;display:none;width:100%}.infinite-loading-text{margin-left:32px;margin-right:32px;margin-top:4px;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.infinite-loading-text{margin-left:unset;margin-right:unset;-webkit-margin-start:32px;margin-inline-start:32px;-webkit-margin-end:32px;margin-inline-end:32px}}.infinite-scroll-loading ion-infinite-scroll-content>.infinite-loading{display:block}.infinite-scroll-content-md .infinite-loading-text{color:var(--ion-color-step-600, #666666)}.infinite-scroll-content-md .infinite-loading-spinner .spinner-lines-md line,.infinite-scroll-content-md .infinite-loading-spinner .spinner-lines-small-md line,.infinite-scroll-content-md .infinite-loading-spinner .spinner-crescent circle{stroke:var(--ion-color-step-600, #666666)}.infinite-scroll-content-md .infinite-loading-spinner .spinner-bubbles circle,.infinite-scroll-content-md .infinite-loading-spinner .spinner-circles circle,.infinite-scroll-content-md .infinite-loading-spinner .spinner-dots circle{fill:var(--ion-color-step-600, #666666)}\";\n\nconst InfiniteScrollContent = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n  }\n  componentDidLoad() {\n    if (this.loadingSpinner === undefined) {\n      const mode = getIonMode(this);\n      this.loadingSpinner = config.get('infiniteLoadingSpinner', config.get('spinner', mode === 'ios' ? 'lines' : 'crescent'));\n    }\n  }\n  render() {\n    const mode = getIonMode(this);\n    return (h(Host, { class: {\n        [mode]: true,\n        // Used internally for styling\n        [`infinite-scroll-content-${mode}`]: true\n      } }, h(\"div\", { class: \"infinite-loading\" }, this.loadingSpinner && (h(\"div\", { class: \"infinite-loading-spinner\" }, h(\"ion-spinner\", { name: this.loadingSpinner }))), this.loadingText && (h(\"div\", { class: \"infinite-loading-text\", innerHTML: sanitizeDOMString(this.loadingText) })))));\n  }\n};\nInfiniteScrollContent.style = {\n  ios: infiniteScrollContentIosCss,\n  md: infiniteScrollContentMdCss\n};\n\nexport { InfiniteScroll as ion_infinite_scroll, InfiniteScrollContent as ion_infinite_scroll_content };\n","/**\n * Does a simple sanitization of all elements\n * in an untrusted string\n */\nconst sanitizeDOMString = (untrustedString) => {\n  try {\n    if (untrustedString instanceof IonicSafeString) {\n      return untrustedString.value;\n    }\n    if (!isSanitizerEnabled() || typeof untrustedString !== 'string' || untrustedString === '') {\n      return untrustedString;\n    }\n    /**\n     * Create a document fragment\n     * separate from the main DOM,\n     * create a div to do our work in\n     */\n    const documentFragment = document.createDocumentFragment();\n    const workingDiv = document.createElement('div');\n    documentFragment.appendChild(workingDiv);\n    workingDiv.innerHTML = untrustedString;\n    /**\n     * Remove any elements\n     * that are blocked\n     */\n    blockedTags.forEach(blockedTag => {\n      const getElementsToRemove = documentFragment.querySelectorAll(blockedTag);\n      for (let elementIndex = getElementsToRemove.length - 1; elementIndex >= 0; elementIndex--) {\n        const element = getElementsToRemove[elementIndex];\n        if (element.parentNode) {\n          element.parentNode.removeChild(element);\n        }\n        else {\n          documentFragment.removeChild(element);\n        }\n        /**\n         * We still need to sanitize\n         * the children of this element\n         * as they are left behind\n         */\n        const childElements = getElementChildren(element);\n        /* tslint:disable-next-line */\n        for (let childIndex = 0; childIndex < childElements.length; childIndex++) {\n          sanitizeElement(childElements[childIndex]);\n        }\n      }\n    });\n    /**\n     * Go through remaining elements and remove\n     * non-allowed attribs\n     */\n    // IE does not support .children on document fragments, only .childNodes\n    const dfChildren = getElementChildren(documentFragment);\n    /* tslint:disable-next-line */\n    for (let childIndex = 0; childIndex < dfChildren.length; childIndex++) {\n      sanitizeElement(dfChildren[childIndex]);\n    }\n    // Append document fragment to div\n    const fragmentDiv = document.createElement('div');\n    fragmentDiv.appendChild(documentFragment);\n    // First child is always the div we did our work in\n    const getInnerDiv = fragmentDiv.querySelector('div');\n    return (getInnerDiv !== null) ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;\n  }\n  catch (err) {\n    console.error(err);\n    return '';\n  }\n};\n/**\n * Clean up current element based on allowed attributes\n * and then recursively dig down into any child elements to\n * clean those up as well\n */\nconst sanitizeElement = (element) => {\n  // IE uses childNodes, so ignore nodes that are not elements\n  if (element.nodeType && element.nodeType !== 1) {\n    return;\n  }\n  for (let i = element.attributes.length - 1; i >= 0; i--) {\n    const attribute = element.attributes.item(i);\n    const attributeName = attribute.name;\n    // remove non-allowed attribs\n    if (!allowedAttributes.includes(attributeName.toLowerCase())) {\n      element.removeAttribute(attributeName);\n      continue;\n    }\n    // clean up any allowed attribs\n    // that attempt to do any JS funny-business\n    const attributeValue = attribute.value;\n    /* tslint:disable-next-line */\n    if (attributeValue != null && attributeValue.toLowerCase().includes('javascript:')) {\n      element.removeAttribute(attributeName);\n    }\n  }\n  /**\n   * Sanitize any nested children\n   */\n  const childElements = getElementChildren(element);\n  /* tslint:disable-next-line */\n  for (let i = 0; i < childElements.length; i++) {\n    sanitizeElement(childElements[i]);\n  }\n};\n/**\n * IE doesn't always support .children\n * so we revert to .childNodes instead\n */\nconst getElementChildren = (el) => {\n  return (el.children != null) ? el.children : el.childNodes;\n};\nconst isSanitizerEnabled = () => {\n  const win = window;\n  const config = win && win.Ionic && win.Ionic.config;\n  if (config) {\n    if (config.get) {\n      return config.get('sanitizerEnabled', true);\n    }\n    else {\n      return config.sanitizerEnabled === true || config.sanitizerEnabled === undefined;\n    }\n  }\n  return true;\n};\nconst allowedAttributes = ['class', 'id', 'href', 'src', 'name', 'slot'];\nconst blockedTags = ['script', 'style', 'iframe', 'meta', 'link', 'object', 'embed'];\nclass IonicSafeString {\n  constructor(value) {\n    this.value = value;\n  }\n}\n\nexport { IonicSafeString as I, sanitizeDOMString as s };\n","import { g as getMode, s as setMode } from './index-7a8b7a1c.js';\n\nconst getPlatforms = (win) => setupPlatforms(win);\nconst isPlatform = (winOrPlatform, platform) => {\n  if (typeof winOrPlatform === 'string') {\n    platform = winOrPlatform;\n    winOrPlatform = undefined;\n  }\n  return getPlatforms(winOrPlatform).includes(platform);\n};\nconst setupPlatforms = (win = window) => {\n  if (typeof win === 'undefined') {\n    return [];\n  }\n  win.Ionic = win.Ionic || {};\n  let platforms = win.Ionic.platforms;\n  if (platforms == null) {\n    platforms = win.Ionic.platforms = detectPlatforms(win);\n    platforms.forEach(p => win.document.documentElement.classList.add(`plt-${p}`));\n  }\n  return platforms;\n};\nconst detectPlatforms = (win) => Object.keys(PLATFORMS_MAP).filter(p => PLATFORMS_MAP[p](win));\nconst isMobileWeb = (win) => isMobile(win) && !isHybrid(win);\nconst isIpad = (win) => {\n  // iOS 12 and below\n  if (testUserAgent(win, /iPad/i)) {\n    return true;\n  }\n  // iOS 13+\n  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {\n    return true;\n  }\n  return false;\n};\nconst isIphone = (win) => testUserAgent(win, /iPhone/i);\nconst isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);\nconst isAndroid = (win) => testUserAgent(win, /android|sink/i);\nconst isAndroidTablet = (win) => {\n  return isAndroid(win) && !testUserAgent(win, /mobile/i);\n};\nconst isPhablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (smallest > 390 && smallest < 520) &&\n    (largest > 620 && largest < 800);\n};\nconst isTablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (isIpad(win) ||\n    isAndroidTablet(win) ||\n    ((smallest > 460 && smallest < 820) &&\n      (largest > 780 && largest < 1400)));\n};\nconst isMobile = (win) => matchMedia(win, '(any-pointer:coarse)');\nconst isDesktop = (win) => !isMobile(win);\nconst isHybrid = (win) => isCordova(win) || isCapacitorNative(win);\nconst isCordova = (win) => !!(win['cordova'] || win['phonegap'] || win['PhoneGap']);\nconst isCapacitorNative = (win) => {\n  const capacitor = win['Capacitor'];\n  return !!(capacitor && capacitor.isNative);\n};\nconst isElectron = (win) => testUserAgent(win, /electron/i);\nconst isPWA = (win) => !!(win.matchMedia('(display-mode: standalone)').matches || win.navigator.standalone);\nconst testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);\nconst matchMedia = (win, query) => win.matchMedia(query).matches;\nconst PLATFORMS_MAP = {\n  'ipad': isIpad,\n  'iphone': isIphone,\n  'ios': isIOS,\n  'android': isAndroid,\n  'phablet': isPhablet,\n  'tablet': isTablet,\n  'cordova': isCordova,\n  'capacitor': isCapacitorNative,\n  'electron': isElectron,\n  'pwa': isPWA,\n  'mobile': isMobile,\n  'mobileweb': isMobileWeb,\n  'desktop': isDesktop,\n  'hybrid': isHybrid\n};\n\nclass Config {\n  constructor() {\n    this.m = new Map();\n  }\n  reset(configObj) {\n    this.m = new Map(Object.entries(configObj));\n  }\n  get(key, fallback) {\n    const value = this.m.get(key);\n    return value !== undefined ? value : fallback;\n  }\n  getBoolean(key, fallback = false) {\n    const val = this.m.get(key);\n    if (val === undefined) {\n      return fallback;\n    }\n    if (typeof val === 'string') {\n      return val === 'true';\n    }\n    return !!val;\n  }\n  getNumber(key, fallback) {\n    const val = parseFloat(this.m.get(key));\n    return isNaN(val) ? (fallback !== undefined ? fallback : NaN) : val;\n  }\n  set(key, value) {\n    this.m.set(key, value);\n  }\n}\nconst config = /*@__PURE__*/ new Config();\nconst configFromSession = (win) => {\n  try {\n    const configStr = win.sessionStorage.getItem(IONIC_SESSION_KEY);\n    return configStr !== null ? JSON.parse(configStr) : {};\n  }\n  catch (e) {\n    return {};\n  }\n};\nconst saveConfig = (win, c) => {\n  try {\n    win.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c));\n  }\n  catch (e) {\n    return;\n  }\n};\nconst configFromURL = (win) => {\n  const configObj = {};\n  win.location.search\n    .slice(1)\n    .split('&')\n    .map(entry => entry.split('='))\n    .map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)])\n    .filter(([key]) => startsWith(key, IONIC_PREFIX))\n    .map(([key, value]) => [key.slice(IONIC_PREFIX.length), value])\n    .forEach(([key, value]) => {\n    configObj[key] = value;\n  });\n  return configObj;\n};\nconst startsWith = (input, search) => {\n  return input.substr(0, search.length) === search;\n};\nconst IONIC_PREFIX = 'ionic:';\nconst IONIC_SESSION_KEY = 'ionic-persist-config';\n\nlet defaultMode;\nconst getIonMode = (ref) => {\n  return (ref && getMode(ref)) || defaultMode;\n};\nconst initialize = (userConfig = {}) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const doc = window.document;\n  const win = window;\n  const Ionic = win.Ionic = win.Ionic || {};\n  // Setup platforms\n  setupPlatforms(win);\n  // create the Ionic.config from raw config object (if it exists)\n  // and convert Ionic.config into a ConfigApi that has a get() fn\n  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win)), { persistConfig: false }), Ionic.config), configFromURL(win)), userConfig);\n  config.reset(configObj);\n  if (config.getBoolean('persistConfig')) {\n    saveConfig(win, configObj);\n  }\n  // first see if the mode was set as an attribute on <html>\n  // which could have been set by the user, or by pre-rendering\n  // otherwise get the mode via config settings, and fallback to md\n  Ionic.config = config;\n  Ionic.mode = defaultMode = config.get('mode', (doc.documentElement.getAttribute('mode')) || (isPlatform(win, 'ios') ? 'ios' : 'md'));\n  config.set('mode', defaultMode);\n  doc.documentElement.setAttribute('mode', defaultMode);\n  doc.documentElement.classList.add(defaultMode);\n  if (config.getBoolean('_testing')) {\n    config.set('animated', false);\n  }\n  const isIonicElement = (elm) => elm.tagName && elm.tagName.startsWith('ION-');\n  const isAllowedIonicModeValue = (elmMode) => ['ios', 'md'].includes(elmMode);\n  setMode((elm) => {\n    while (elm) {\n      const elmMode = elm.mode || elm.getAttribute('mode');\n      if (elmMode) {\n        if (isAllowedIonicModeValue(elmMode)) {\n          return elmMode;\n        }\n        else if (isIonicElement(elm)) {\n          console.warn('Invalid ionic mode: \"' + elmMode + '\", expected: \"ios\" or \"md\"');\n        }\n      }\n      elm = elm.parentElement;\n    }\n    return defaultMode;\n  });\n};\n\nexport { isPlatform as a, getIonMode as b, config as c, getPlatforms as g, initialize as i };\n"],"sourceRoot":"webpack:///"}