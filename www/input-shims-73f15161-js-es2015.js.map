{"version":3,"sources":["./node_modules/@ionic/core/dist/esm/helpers-dd7e4b7b.js","./node_modules/@ionic/core/dist/esm/input-shims-73f15161.js","./node_modules/@ionic/angular/node_modules/@ionic/core/dist/esm/input-shims-73f15161.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoU;;;;;;;;;;;;;ACtPpU;AAAA;AAAA;AAA4I;;AAE5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG,KAAK,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8DAAgB;AAClB,EAAE,8DAAgB;AAClB;AACA;AACA,IAAI,8DAAmB;AACvB,IAAI,8DAAmB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,EAAE,8DAAgB;AAClB;AACA;AACA;AACA,IAAI,8DAAmB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,8DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8DAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAE2B;;;;;;;;;;;;;AC7Y3B;AAAA;AAAA;AAA4I;;AAE5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG,KAAK,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8DAAgB;AAClB,EAAE,8DAAgB;AAClB;AACA;AACA,IAAI,8DAAmB;AACvB,IAAI,8DAAmB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,EAAE,8DAAgB;AAClB;AACA;AACA;AACA,IAAI,8DAAmB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,8DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8DAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAE2B","file":"input-shims-73f15161-js-es2015.js","sourcesContent":["/**\n * Waits for a component to be ready for\n * both custom element and non-custom element builds.\n * If non-custom element build, el.componentOnReady\n * will be used.\n * For custom element builds, we wait a frame\n * so that the inner contents of the component\n * have a chance to render.\n *\n * Use this utility rather than calling\n * el.componentOnReady yourself.\n */\nconst componentOnReady = (el, callback) => {\n  if (el.componentOnReady) {\n    el.componentOnReady().then((resolvedEl) => callback(resolvedEl));\n  }\n  else {\n    raf(() => callback(el));\n  }\n};\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      }\n      else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.addEventListener(eventName, callback, opts);\n};\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      }\n      else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nconst hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\nconst findItemLabel = (componentEl) => {\n  const itemEl = componentEl.closest('ion-item');\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n  return null;\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText;\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.getElementById(labelledBy)\n    : findItemLabel(componentEl);\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n    // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  }\n  else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      }\n      else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n      labelText = label.textContent;\n    }\n  }\n  return { label, labelId, labelText };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n    throw new Error(message);\n  }\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\nconst pointerCoord = (ev) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return { x: touch.clientX, y: touch.clientY };\n    }\n    if (ev.pageX !== undefined) {\n      return { x: ev.pageX, y: ev.pageY };\n    }\n  }\n  return { x: 0, y: 0 };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\nconst isEndSide = (side) => {\n  const isRTL = document.dir === 'rtl';\n  switch (side) {\n    case 'start': return isRTL;\n    case 'end': return !isRTL;\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n\nexport { addEventListener as a, removeEventListener as b, componentOnReady as c, getAriaLabel as d, renderHiddenInput as e, debounceEvent as f, getElementRoot as g, findItemLabel as h, inheritAttributes as i, clamp as j, hasShadowDom as k, assert as l, isEndSide as m, debounce as n, now as o, pointerCoord as p, raf as r };\n","import { a as addEventListener, b as removeEventListener, r as raf, p as pointerCoord, c as componentOnReady } from './helpers-dd7e4b7b.js';\n\nconst cloneMap = new WeakMap();\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  }\n  else {\n    removeClone(componentEl, inputEl);\n  }\n};\nconst isFocused = (input) => {\n  return input === input.getRootNode().activeElement;\n};\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  const parentEl = inputEl.parentNode;\n  // DOM WRITES\n  const clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  const doc = componentEl.ownerDocument;\n  const tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\n};\nconst removeClone = (componentEl, inputEl) => {\n  const clone = cloneMap.get(componentEl);\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\n  if (!scrollEl || !inputEl) {\n    return () => { return; };\n  }\n  const scrollHideCaret = (shouldHideCaret) => {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n  const onBlur = () => relocateInput(componentEl, inputEl, false);\n  const hideCaret = () => scrollHideCaret(true);\n  const showCaret = () => scrollHideCaret(false);\n  addEventListener(scrollEl, 'ionScrollStart', hideCaret);\n  addEventListener(scrollEl, 'ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return () => {\n    removeEventListener(scrollEl, 'ionScrollStart', hideCaret);\n    removeEventListener(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\nconst enableInputBlurring = () => {\n  let focused = true;\n  let didScroll = false;\n  const doc = document;\n  const onScroll = () => {\n    didScroll = true;\n  };\n  const onFocusin = () => {\n    focused = true;\n  };\n  const onTouchend = (ev) => {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n    const active = doc.activeElement;\n    if (!active) {\n      return;\n    }\n    // only blur if the active element is a text-input or a textarea\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    }\n    // if the selected target is the active element, do not blur\n    const tapped = ev.target;\n    if (tapped === active) {\n      return;\n    }\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n    focused = false;\n    // TODO: find a better way, why 50ms?\n    setTimeout(() => {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n  addEventListener(doc, 'ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return () => {\n    removeEventListener(doc, 'ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\n  const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\n  // compute input's Y values relative to the body\n  const inputTop = inputRect.top;\n  const inputBottom = inputRect.bottom;\n  // compute visible area\n  const visibleAreaTop = contentRect.top;\n  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n  // compute safe area\n  const safeAreaTop = visibleAreaTop + 15;\n  const safeAreaBottom = visibleAreaBottom * 0.75;\n  // figure out if each edge of the input is within the safe area\n  const distanceToBottom = safeAreaBottom - inputBottom;\n  const distanceToTop = safeAreaTop - inputTop;\n  // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n  const desiredScrollAmount = Math.round((distanceToBottom < 0)\n    ? -distanceToBottom\n    : (distanceToTop > 0)\n      ? -distanceToTop\n      : 0);\n  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  const distance = Math.abs(scrollAmount);\n  const duration = distance / SCROLL_ASSIST_SPEED;\n  const scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount,\n    scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  let coord;\n  const touchStart = (ev) => {\n    coord = pointerCoord(ev);\n  };\n  const touchEnd = (ev) => {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    }\n    // get where the touchend/mouseup ended\n    const endCoord = pointerCoord(ev);\n    // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.stopPropagation();\n      // begin the input focus process\n      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n    }\n  };\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return () => {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  if (!contentEl && !footerEl) {\n    return;\n  }\n  const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);\n  if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  }\n  // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus();\n  /**\n   * Relocating/Focusing input causes the\n   * click event to be cancelled, so\n   * manually fire one here.\n   */\n  raf(() => componentEl.click());\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined') {\n    let scrollContentTimeout;\n    const scrollContent = async () => {\n      // clean up listeners and timeouts\n      if (scrollContentTimeout !== undefined) {\n        clearTimeout(scrollContentTimeout);\n      }\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.removeEventListener('ionKeyboardDidShow', scrollContent);\n      // scroll the input into place\n      if (contentEl) {\n        await contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration);\n      }\n      // the scroll view is in the correct position now\n      // give the native text input focus\n      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n      // ensure this is the focused input\n      inputEl.focus();\n    };\n    const doubleKeyboardEventListener = () => {\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.addEventListener('ionKeyboardDidShow', scrollContent);\n    };\n    if (contentEl) {\n      const scrollEl = await contentEl.getScrollElement();\n      /**\n       * scrollData will only consider the amount we need\n       * to scroll in order to properly bring the input\n       * into view. It will not consider the amount\n       * we can scroll in the content element.\n       * As a result, scrollData may request a greater\n       * scroll position than is currently available\n       * in the DOM. If this is the case, we need to\n       * wait for the webview to resize/the keyboard\n       * to show in order for additional scroll\n       * bandwidth to become available.\n       */\n      const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n      if (scrollData.scrollAmount > (totalScrollAmount - scrollEl.scrollTop)) {\n        /**\n         * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n         * after the initial keyboard is shown. This prevents the webview from resizing\n         * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n         */\n        if (inputEl.type === 'password') {\n          // Add 50px to account for the \"Passwords\" bar\n          scrollData.scrollAmount += 50;\n          window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n        }\n        else {\n          window.addEventListener('ionKeyboardDidShow', scrollContent);\n        }\n        /**\n         * This should only fire in 2 instances:\n         * 1. The app is very slow.\n         * 2. The app is running in a browser on an old OS\n         * that does not support Ionic Keyboard Events\n         */\n        scrollContentTimeout = setTimeout(scrollContent, 1000);\n        return;\n      }\n    }\n    scrollContent();\n  }\n};\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\n  if (startCoord && endCoord) {\n    const deltaX = (startCoord.x - endCoord.x);\n    const deltaY = (startCoord.y - endCoord.y);\n    const distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > (threshold * threshold);\n  }\n  return false;\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\nconst enableScrollPadding = (keyboardHeight) => {\n  const doc = document;\n  const onFocusin = (ev) => {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n  const onFocusout = (ev) => {\n    setScrollPadding(ev.target, 0);\n  };\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return () => {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\nconst setScrollPadding = (input, keyboardHeight) => {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n  if (input.parentElement &&\n    input.parentElement.parentElement &&\n    input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n  const el = input.closest('ion-content');\n  if (el === null) {\n    return;\n  }\n  const timer = el[PADDING_TIMER_KEY];\n  if (timer) {\n    clearTimeout(timer);\n  }\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\n  }\n  else {\n    el[PADDING_TIMER_KEY] = setTimeout(() => {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nconst INPUT_BLURRING = true;\nconst SCROLL_PADDING = true;\nconst startInputShims = (config) => {\n  const doc = document;\n  const keyboardHeight = config.getNumber('keyboardHeight', 290);\n  const scrollAssist = config.getBoolean('scrollAssist', true);\n  const hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  const inputBlurring = config.getBoolean('inputBlurring', true);\n  const scrollPadding = config.getBoolean('scrollPadding', true);\n  const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  const hideCaretMap = new WeakMap();\n  const scrollAssistMap = new WeakMap();\n  const registerInput = async (componentEl) => {\n    await new Promise(resolve => componentOnReady(componentEl, resolve));\n    const inputRoot = componentEl.shadowRoot || componentEl;\n    const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n    const scrollEl = componentEl.closest('ion-content');\n    const footerEl = (!scrollEl) ? componentEl.closest('ion-footer') : null;\n    if (!inputEl) {\n      return;\n    }\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n    if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  };\n  const unregisterInput = (componentEl) => {\n    if (hideCaret) {\n      const fn = hideCaretMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      hideCaretMap.delete(componentEl);\n    }\n    if (scrollAssist) {\n      const fn = scrollAssistMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  }\n  // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n  for (const input of inputs) {\n    registerInput(input);\n  }\n  doc.addEventListener('ionInputDidLoad', ((ev) => {\n    registerInput(ev.detail);\n  }));\n  doc.addEventListener('ionInputDidUnload', ((ev) => {\n    unregisterInput(ev.detail);\n  }));\n};\n\nexport { startInputShims };\n","import { a as addEventListener, b as removeEventListener, r as raf, p as pointerCoord, c as componentOnReady } from './helpers-dd7e4b7b.js';\n\nconst cloneMap = new WeakMap();\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  }\n  else {\n    removeClone(componentEl, inputEl);\n  }\n};\nconst isFocused = (input) => {\n  return input === input.getRootNode().activeElement;\n};\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  const parentEl = inputEl.parentNode;\n  // DOM WRITES\n  const clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  const doc = componentEl.ownerDocument;\n  const tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\n};\nconst removeClone = (componentEl, inputEl) => {\n  const clone = cloneMap.get(componentEl);\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\n  if (!scrollEl || !inputEl) {\n    return () => { return; };\n  }\n  const scrollHideCaret = (shouldHideCaret) => {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n  const onBlur = () => relocateInput(componentEl, inputEl, false);\n  const hideCaret = () => scrollHideCaret(true);\n  const showCaret = () => scrollHideCaret(false);\n  addEventListener(scrollEl, 'ionScrollStart', hideCaret);\n  addEventListener(scrollEl, 'ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return () => {\n    removeEventListener(scrollEl, 'ionScrollStart', hideCaret);\n    removeEventListener(scrollEl, 'ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nconst SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';\nconst enableInputBlurring = () => {\n  let focused = true;\n  let didScroll = false;\n  const doc = document;\n  const onScroll = () => {\n    didScroll = true;\n  };\n  const onFocusin = () => {\n    focused = true;\n  };\n  const onTouchend = (ev) => {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n    const active = doc.activeElement;\n    if (!active) {\n      return;\n    }\n    // only blur if the active element is a text-input or a textarea\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    }\n    // if the selected target is the active element, do not blur\n    const tapped = ev.target;\n    if (tapped === active) {\n      return;\n    }\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n    focused = false;\n    // TODO: find a better way, why 50ms?\n    setTimeout(() => {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n  addEventListener(doc, 'ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return () => {\n    removeEventListener(doc, 'ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nconst SCROLL_ASSIST_SPEED = 0.3;\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\n  const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\n  // compute input's Y values relative to the body\n  const inputTop = inputRect.top;\n  const inputBottom = inputRect.bottom;\n  // compute visible area\n  const visibleAreaTop = contentRect.top;\n  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n  // compute safe area\n  const safeAreaTop = visibleAreaTop + 15;\n  const safeAreaBottom = visibleAreaBottom * 0.75;\n  // figure out if each edge of the input is within the safe area\n  const distanceToBottom = safeAreaBottom - inputBottom;\n  const distanceToTop = safeAreaTop - inputTop;\n  // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n  const desiredScrollAmount = Math.round((distanceToBottom < 0)\n    ? -distanceToBottom\n    : (distanceToTop > 0)\n      ? -distanceToTop\n      : 0);\n  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  const distance = Math.abs(scrollAmount);\n  const duration = distance / SCROLL_ASSIST_SPEED;\n  const scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount,\n    scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nconst enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  let coord;\n  const touchStart = (ev) => {\n    coord = pointerCoord(ev);\n  };\n  const touchEnd = (ev) => {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    }\n    // get where the touchend/mouseup ended\n    const endCoord = pointerCoord(ev);\n    // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.stopPropagation();\n      // begin the input focus process\n      jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight);\n    }\n  };\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return () => {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\nconst jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight) => {\n  if (!contentEl && !footerEl) {\n    return;\n  }\n  const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);\n  if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  }\n  // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus();\n  /**\n   * Relocating/Focusing input causes the\n   * click event to be cancelled, so\n   * manually fire one here.\n   */\n  raf(() => componentEl.click());\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined') {\n    let scrollContentTimeout;\n    const scrollContent = async () => {\n      // clean up listeners and timeouts\n      if (scrollContentTimeout !== undefined) {\n        clearTimeout(scrollContentTimeout);\n      }\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.removeEventListener('ionKeyboardDidShow', scrollContent);\n      // scroll the input into place\n      if (contentEl) {\n        await contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration);\n      }\n      // the scroll view is in the correct position now\n      // give the native text input focus\n      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n      // ensure this is the focused input\n      inputEl.focus();\n    };\n    const doubleKeyboardEventListener = () => {\n      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n      window.addEventListener('ionKeyboardDidShow', scrollContent);\n    };\n    if (contentEl) {\n      const scrollEl = await contentEl.getScrollElement();\n      /**\n       * scrollData will only consider the amount we need\n       * to scroll in order to properly bring the input\n       * into view. It will not consider the amount\n       * we can scroll in the content element.\n       * As a result, scrollData may request a greater\n       * scroll position than is currently available\n       * in the DOM. If this is the case, we need to\n       * wait for the webview to resize/the keyboard\n       * to show in order for additional scroll\n       * bandwidth to become available.\n       */\n      const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;\n      if (scrollData.scrollAmount > (totalScrollAmount - scrollEl.scrollTop)) {\n        /**\n         * On iOS devices, the system will show a \"Passwords\" bar above the keyboard\n         * after the initial keyboard is shown. This prevents the webview from resizing\n         * until the \"Passwords\" bar is shown, so we need to wait for that to happen first.\n         */\n        if (inputEl.type === 'password') {\n          // Add 50px to account for the \"Passwords\" bar\n          scrollData.scrollAmount += 50;\n          window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);\n        }\n        else {\n          window.addEventListener('ionKeyboardDidShow', scrollContent);\n        }\n        /**\n         * This should only fire in 2 instances:\n         * 1. The app is very slow.\n         * 2. The app is running in a browser on an old OS\n         * that does not support Ionic Keyboard Events\n         */\n        scrollContentTimeout = setTimeout(scrollContent, 1000);\n        return;\n      }\n    }\n    scrollContent();\n  }\n};\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\n  if (startCoord && endCoord) {\n    const deltaX = (startCoord.x - endCoord.x);\n    const deltaY = (startCoord.y - endCoord.y);\n    const distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > (threshold * threshold);\n  }\n  return false;\n};\n\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\nconst enableScrollPadding = (keyboardHeight) => {\n  const doc = document;\n  const onFocusin = (ev) => {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n  const onFocusout = (ev) => {\n    setScrollPadding(ev.target, 0);\n  };\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return () => {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\nconst setScrollPadding = (input, keyboardHeight) => {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n  if (input.parentElement &&\n    input.parentElement.parentElement &&\n    input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n  const el = input.closest('ion-content');\n  if (el === null) {\n    return;\n  }\n  const timer = el[PADDING_TIMER_KEY];\n  if (timer) {\n    clearTimeout(timer);\n  }\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\n  }\n  else {\n    el[PADDING_TIMER_KEY] = setTimeout(() => {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nconst INPUT_BLURRING = true;\nconst SCROLL_PADDING = true;\nconst startInputShims = (config) => {\n  const doc = document;\n  const keyboardHeight = config.getNumber('keyboardHeight', 290);\n  const scrollAssist = config.getBoolean('scrollAssist', true);\n  const hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  const inputBlurring = config.getBoolean('inputBlurring', true);\n  const scrollPadding = config.getBoolean('scrollPadding', true);\n  const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  const hideCaretMap = new WeakMap();\n  const scrollAssistMap = new WeakMap();\n  const registerInput = async (componentEl) => {\n    await new Promise(resolve => componentOnReady(componentEl, resolve));\n    const inputRoot = componentEl.shadowRoot || componentEl;\n    const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');\n    const scrollEl = componentEl.closest('ion-content');\n    const footerEl = (!scrollEl) ? componentEl.closest('ion-footer') : null;\n    if (!inputEl) {\n      return;\n    }\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n    if ((!!scrollEl || !!footerEl) && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  };\n  const unregisterInput = (componentEl) => {\n    if (hideCaret) {\n      const fn = hideCaretMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      hideCaretMap.delete(componentEl);\n    }\n    if (scrollAssist) {\n      const fn = scrollAssistMap.get(componentEl);\n      if (fn) {\n        fn();\n      }\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  }\n  // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n  for (const input of inputs) {\n    registerInput(input);\n  }\n  doc.addEventListener('ionInputDidLoad', ((ev) => {\n    registerInput(ev.detail);\n  }));\n  doc.addEventListener('ionInputDidUnload', ((ev) => {\n    unregisterInput(ev.detail);\n  }));\n};\n\nexport { startInputShims };\n"],"sourceRoot":"webpack:///"}